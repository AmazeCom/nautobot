# Generated by Django 3.2.16 on 2022-11-19 23:15

from collections import namedtuple
from django.db import migrations, models

from nautobot.ipam.choices import IPAddressRoleChoices


# Role Models or RoleChoices that would be integrated into this Role model are referred to as RelatedRoleModelOrChoices.
# For Example: DeviceRole, RackRole, IPAddressRoleChoices e.t.c.
# while implemented_by refers to the model that actually implements the Related Model/Choice.
# e.g role = models.ForeignKey(to=DeviceRole, ...)
RelatedRoleModelOrChoices = namedtuple("RelatedRoleModelOrChoices", ["model_or_choices", "implemented_by"])

# Using this, Choices is made to resemble a Role Queryset.
ChoicesQuerySet = namedtuple("FakeQuerySet", ["name", "slug", "description", "color"])


def populate_roles_from_related_app_roles(apps, schema_editor):
    """Populate Role models using records from other related role models or choices from different apps."""

    Role = apps.get_model("extras", "Role")
    ContentType = apps.get_model("contenttypes", "ContentType")

    related_role_models_or_choices = (
        RelatedRoleModelOrChoices("dcim.DeviceRole", ["dcim.device", "virtualization.virtualmachine"]),
        RelatedRoleModelOrChoices("dcim.RackRole", ["dcim.rack"]),
        RelatedRoleModelOrChoices("ipam.Role", ["ipam.rack", "ipam.vlan"]),
        RelatedRoleModelOrChoices("ipam.Role", ["ipam.rack", "ipam.vlan"]),
        RelatedRoleModelOrChoices(IPAddressRoleChoices, ["ipam.ipaddress"]),
    )

    color_map = {
        "default": "9e9e9e",  # Grey
        "primary": "2196f3",  # Blue
        "warning": "ffc107",  # Amber
        "success": "4caf50",  # Green
    }

    for role_model_or_choices in related_role_models_or_choices:
        try:
            app_name, model_class = role_model_or_choices.model_or_choices.split(".")
            related_role_model_class = apps.get_model(app_name, model_class)
            existing_roles = Role.objects.values_list("name", flat=True)
            roles_to_create = related_role_model_class.objects.filter(~models.Q(name__in=existing_roles))
        except AttributeError:
            # An AttributeError would occur when trying to perform a split on a choice e.g. IPAddressRoleChoices
            roles_to_create = []

            for value, label in role_model_or_choices.model_or_choices.CHOICES:
                color = role_model_or_choices.model_or_choices.CSS_CLASSES[value]
                choiceset = ChoicesQuerySet(
                    name=label,
                    slug=value,
                    color=color_map[color],
                    description=""
                )
                roles_to_create.append(choiceset)

        roles = [
            Role(
                name=data.name,
                slug=data.slug,
                description=data.description,
                color=data.color if hasattr(data, "color") else color_map["default"],
                weight=data.weight if hasattr(data, "weight") else None,
            )
            for data in roles_to_create
        ]
        role_instances = Role.objects.bulk_create(roles, batch_size=1000)

        filter_ct_by = models.Q()
        for app_and_model in role_model_or_choices.implemented_by:
            app_label, model_name = app_and_model.split(".")
            filter_ct_by |= models.Q(app_label=app_label, model=model_name)

        content_types = ContentType.objects.filter(filter_ct_by)
        for role in role_instances:
            role.content_types.set(content_types)


def clear_populated_roles(apps, schema_editor):
    Role = apps.get_model("extras", "Role")
    Role.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ("extras", "0054_role_and_alter_status"),
    ]

    operations = [
        migrations.RunPython(populate_roles_from_related_app_roles, clear_populated_roles),
    ]
