# Generated by Django 3.2.16 on 2022-11-19 23:15

from collections import namedtuple
from django.db import migrations, models

from nautobot.ipam.choices import IPAddressRoleChoices


# Role Models or RoleChoices that would be integrated into this Role model are referred to as RelatedRoleModelOrChoices.
# For Example: DeviceRole, RackRole, IPAddressRoleChoices e.t.c.
# while implemented_by refers to the model that actually implements the Related Model/Choice.
# e.g role = models.ForeignKey(to=DeviceRole, ...)
RelatedRoleModelOrChoices = namedtuple("RelatedRoleModelOrChoices", ["model_or_choices", "implemented_by"])

# Using this, Choices is made to resemble a Role Queryset.
ChoicesQuerySet = namedtuple("FakeQuerySet", ["name", "description"])


def populate_roles_from_related_app_roles(apps, schema_editor):
    """Populate Role models using records from other related role models or choices from different apps."""

    Role = apps.get_model("extras", "Role")
    ContentType = apps.get_model("contenttypes", "ContentType")

    related_role_models_or_choices = (
        RelatedRoleModelOrChoices("dcim.DeviceRole", ["dcim.device", "virtualization.virtualmachine"]),
        RelatedRoleModelOrChoices("dcim.RackRole", ["dcim.rack"]),
        RelatedRoleModelOrChoices("ipam.Role", ["ipam.rack", "ipam.vlan"]),
        RelatedRoleModelOrChoices("ipam.Role", ["ipam.rack", "ipam.vlan"]),
        RelatedRoleModelOrChoices(IPAddressRoleChoices, ["ipam.ipaddress"]),
    )

    for role_model_or_choices in related_role_models_or_choices:
        try:
            app_name, model_class = role_model_or_choices.model_or_choices.split(".")
            related_role_model_class = apps.get_model(app_name, model_class)
            existing_roles = Role.objects.values_list("name", flat=True)
            roles_to_create = related_role_model_class.objects.filter(~models.Q(name__in=existing_roles))
        except AttributeError:
            # An AttributeError would occur when trying to perform a split on a choice e.g. IPAddressRoleChoices
            roles_to_create = [
                ChoicesQuerySet(name=label, description="")
                for _, label in role_model_or_choices.model_or_choices.CHOICES
            ]

        roles = [
            Role(
                name=data.name,
                description=data.description,
                weight=data.weight if hasattr(data, "weight") else None,
            )
            for data in roles_to_create
        ]
        role_instances = Role.objects.bulk_create(roles, batch_size=1000)

        filter_ct_by = models.Q()
        for app_and_model in role_model_or_choices.implemented_by:
            app_label, model_name = app_and_model.split(".")
            filter_ct_by |= models.Q(app_label=app_label, model=model_name)

        content_types = ContentType.objects.filter(filter_ct_by)
        for role in role_instances:
            role.content_types.set(content_types)


def clear_populated_roles(apps, schema_editor):
    Role = apps.get_model("extras", "Role")
    Role.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ("extras", "0054_role_and_alter_status"),
    ]

    operations = [
        migrations.RunPython(populate_roles_from_related_app_roles, clear_populated_roles),
    ]
